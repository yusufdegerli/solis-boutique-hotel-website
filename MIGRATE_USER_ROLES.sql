-- 1. Create user_roles table
CREATE TABLE IF NOT EXISTS "public"."user_roles" (
  "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "user_id" uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  "role" text NOT NULL DEFAULT 'user',
  "created_at" timestamp with time zone DEFAULT now(),
  UNIQUE("user_id")
);

-- 2. Enable RLS
ALTER TABLE "public"."user_roles" ENABLE ROW LEVEL SECURITY;

-- 3. Policies
-- Users can read their own role
CREATE POLICY "Users can read own role" ON "public"."user_roles"
  FOR SELECT USING (auth.uid() = user_id);

-- Admins can read all roles (Recursive policy need careful handling, 
-- usually we rely on Service Role for admin management or a separate function)
-- For now, allow Service Role (default) and users to read own.

-- 4. Trigger to create entry on signup
CREATE OR REPLACE FUNCTION "public"."handle_new_user"() 
RETURNS TRIGGER 
LANGUAGE plpgsql 
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  INSERT INTO public.user_roles (user_id, role)
  VALUES (new.id, 'user');
  RETURN new;
END;
$$;

-- Drop trigger if exists to avoid error
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- 5. Helper function to check if user is admin (for RLS policies elsewhere)
CREATE OR REPLACE FUNCTION "public"."is_admin"() 
RETURNS boolean 
LANGUAGE plpgsql 
SECURITY DEFINER
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.user_roles 
    WHERE user_id = auth.uid() 
    AND role = 'admin'
  );
END;
$$;

-- 6. EXAMPLE: Make a user admin (Run this manually in SQL Editor)
-- UPDATE public.user_roles SET role = 'admin' 
-- WHERE user_id = (SELECT id FROM auth.users WHERE email = 'YOUR_EMAIL@example.com');
